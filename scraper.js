'use strict';

/**
 * requires
 */
const assert = require('assert');
const http = require('./engines/http');
const inspect = require('./inspect');
const Context = require('./context');
const cheerio = require('cheerio');
const url = require('url');
const Filters = require('./filters');

/**
 * Scraper class
 */
class Scraper {
  /**
   * Construct new scraper
   * @param  {string|object} options optional, if string as from if object populate attributes
   */
  constructor(options, origin) {
    origin = origin || {};

    this.engineFn = origin.engineFn || http();
    this.nextFn = origin.nextFn || null;
    this.filters = origin.filters || new Filters();
    this.pageLimit = origin.pageLimit || -1;
    this.middlewares = origin.middlewares || [];

    // from, body, selector wont be populated from origin must be specified explicitly
    this.from = null;
    this.body = null;
    this.selector = null;

    // underscore-prefixed prop wont be populated, generated by behavior
    this._cacheFilters = {};
    this._compiled = null;
    this._pageIndex = 0;

    if (options) {
      switch(typeof options) {
        case 'string':
          if (isURL(options)) {
            this.from = options;
          } else {
            this.body = options;
          }
          break;
        case 'object':
          /* istanbul ignore else */
          if (options.$from) this.from = options.$from;
          else if (options.$body) this.body = options.$body;

          if (options.$select) this.select(options.$select);
          break;
        default:
          throw new Error('Scraper only accept string or object');
      }
    }
  }

  /**
   * Add or modify selector, returning own instance so it can be chained
   * @param  {string|object} selector must be string or object
   * @return {Scraper}
   */
  select(selector) {
    this.selector = selector;
    this._compiled = this.compile(selector);
    return this;
  }

  filter(name, fn) {
    if (!fn) {
      if (this._cacheFilters[name]) {
        return this._cacheFilters[name];
      }

      let rawArgs = name.split(':');
      let rawName = rawArgs.shift();
      let raw = this.filters[rawName];

      if (!raw) {
        throw new Error('Unknown filter ' + rawName);
      }

      let filter = raw;
      if (0 < rawArgs.length) {
        filter = function(value) {
          let args = [value];
          args.push.apply(args, rawArgs);
          return raw.apply(null, args);
        };
      }
      this._cacheFilters[name] = filter;
      return filter;
    }

    this.filters[name] = fn;
    return this;
  }

  /**
   * Compile selector into function selector
   * @param  {mixed} selector
   * @return {function}
   */
  compile(selector, multi) {
    multi = multi || false;
    if (!multi && Array.isArray(selector)) {
      return this.compile(selector[0], true);
    }

    let originSelf = this;
    let originFrom = this.from;

    switch(typeof selector) {
      case 'function':
        return selector;
      case 'object':
        if (selector.$from || selector.$body) {
          let _fromFn;
          if (selector.$from) {
            _fromFn = this.compile(selector.$from);
          }
          return function($root) {
            let options = clone(selector);
            if (_fromFn) {
              options.$from = url.resolve(originFrom, _fromFn($root));
            }
            return (new Scraper(options, originSelf)).fetch();
          };
        }
        let fields = [];
        for(let i in selector) {
          if ('$root' === i) continue;
          fields.push([i, this.compile(selector[i])]);
        }

        let _mapObject = function(i, el) {
          return Promise.all(fields.map(field => {
            return field[1](cheerio(el));
          }))
          .then(result => {
            return fields.reduce((obj, field, k) => {
              obj[field[0]] = result[k];
              return obj;
            }, {});
          });
        }.bind(this);

        return function($root) {
          $root = selector.$root ? $root.find(selector.$root) : $root;
          if (multi) {
            return Promise.all(
              $root.map(_mapObject).get()
            );
          } else {
            return _mapObject(0, $root);
          }
        };
      case 'string':
        let rawFilters = selector.split('|').map(s => s.trim());
        let sel = rawFilters.shift().split('@').map(s => s.trim());
        let objectSel = sel[0] || '';
        let fieldSel = sel[1] || 'text';
        let filters = rawFilters.map(function (filter) {
          return this.filter(filter);
        }.bind(this));

        let _mapScalar = function(i, el) {
          let $el = cheerio(el);
          let value;
          switch(fieldSel) {
            case 'html':
            case 'text':
              value = $el[fieldSel]();
              break;
            default:
              value = $el.attr(fieldSel);
              break;
          }

          value = filters.reduce((value, filter) => {
            return Promise.resolve(value).then(v => filter(v));
          }, value);

          // TODO filters
          return value;
        };

        return function($root) {
          $root = objectSel ? $root.find(objectSel) : $root;
          if (multi) {
            return Promise.all($root.map(_mapScalar).get());
          } else {
            return _mapScalar(0, $root);
          }
        };
      default:
        throw new Error('Selector must be string, function or object');
    }
  }

  isPaginated() {
    return !!this.nextFn;
  }

  /**
   * Fetch each row if parameter is function, or return promise if no parameter specified
   * @param  {function} fn optional fetcher function
   * @return {Promise}
   */
  fetch(fn) {
    if (this.isPaginated() && 'function' !== typeof fn) {
      throw new Error('Multi pages scraping detected, must specified reader function');
    }

    let middleware = this.middlewares;
    let runMiddlewares = function (context, next) {
      // last called middleware #
      let index = -1;
      return dispatch(0);
      function dispatch (i) {
        // do we need this
        // if (i <= index) return Promise.reject(new Error('next() called multiple times'));
        index = i;
        const fn = middleware[i] || next;
        // next must be specified from internal
        // if (!fn) return Promise.resolve();
        try {
          return Promise.resolve(fn(context, function next () {
            return dispatch(i + 1);
          }));
        } catch (err) {
          return Promise.reject(err);
        }
      }
    };

    let _getValue = function(body) {
      let $root = this.getRoot(body);
      let valuePromised;
      if (this._compiled) {
        valuePromised = this._compiled($root);
      } else if ($root) {
        valuePromised = $root.text();
      } else {
        valuePromised = body;
      }

      return Promise.resolve(valuePromised)
        .then(function (data) {
          let hasdata = null !== data && undefined !== data;
          let dataRows = hasdata ? (Array.isArray(data) ? data : [data]) : /* istanbul ignore next */ [];

          if (fn) {
            dataRows.forEach(row => fn(row));
          }

          if (hasdata && this.isPaginated()) {
            this._pageIndex++;

            let from = this.next();
            if (from) {
              let scraper = new Scraper({
                $from: from,
                $select: this.selector,
              }, this);

              // copy _pageIndex
              scraper._pageIndex = this._pageIndex;

              return scraper
                .fetch(fn)
                .then((numRows) => {
                  return dataRows.length + numRows;
                });
            }
            return dataRows.length;
          } else {
            return data;
          }
        }.bind(this));
    }.bind(this);

    if (this.from) {
      let engine = this.engine();
      let context = new Context(this.from);

      return runMiddlewares(context, function() {
        return engine(context)
          .then(function() {
            this.body = context.body;
            return _getValue(context.body);
          }.bind(this));
      }.bind(this));
    } else {
      return _getValue(this.body);
    }

  }

  /**
   * Get root from body
   * @param  {mixed} body
   * @return {mixed}
   */
  getRoot(body) {
    if ('string' === typeof body) {
      return cheerio(cheerio.load(body)._root);
    }
  }

  /**
   * Get or set engine
   * @param  {function} fn if specified set engine otherwise get
   * @return {function|Scraper} if parameter specified return function otherwise return own instance of Scraper
   */
  engine(fn) {
    if (0 === arguments.length) {
      return this.engineFn;
    }
    this.engineFn = fn;
    return this;
  }

  /**
   * Overrride inspect for easy debugging
   * @return {object}
   */
  inspect() {
    return inspect(this, ['from', 'selector']);
  }

  /**
   * When nextVal specified will update nextFn, otherwise get nextUrl
   * @param  {mixed}   nextVal
   * @return {function|Scraper}
   */
  next(nextVal) {
    /* istanbul ignore else */
    if (arguments.length) {
      let nextCb;
      if ('function' === typeof nextVal) {
        this.nextFn = nextVal;
      } else {
        let compiled = this.compile(nextVal);
        this.nextFn = function(s) {
          let $root = s.getRoot(s.body);
          return url.resolve(s.from, compiled($root));
        };
      }
      return this;
    } else if (this.nextFn && (this.pageLimit < 0 || this.pageLimit > this._pageIndex)) {
      return this.nextFn(this);
    }
  }

  /**
   * When pageLimit specified will update pageLimit, otherwise get pageLimit
   * @param  {int} pageLimit
   * @return {int|Scraper}
   */
  limit(pageLimit) {
    if (arguments.length) {
      this.pageLimit = pageLimit;
      return this;
    } else {
      return this.pageLimit;
    }
  }

  use(middleware) {
    this.middlewares.push(middleware);
    return this;
  }
}

function isURL(str) {
  return null !== url.parse(str).protocol;
}

function clone(obj) {
  let cloned = {};
  for(let i in obj) {
    cloned[i] = obj[i];
  }
  return cloned;
}

/**
 * export Scraper
 * @type {Scraper}
 */
module.exports = Scraper;
